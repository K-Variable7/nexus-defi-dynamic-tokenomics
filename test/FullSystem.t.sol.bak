// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/PlatformFactory.sol";
import "../src/utils/MockRouter.sol";
import "../src/utils/MockWETH.sol";
import "../src/VariableTaxToken.sol";
import "../src/StakingPool.sol";
import "../src/MultiplierVault.sol";
import "../src/Lottery.sol";
import "../src/Roulette.sol";
import "../src/utils/MockLP.sol";
import "../src/LiquidityLocker.sol";
import "@chainlink/contracts/src/v0.8/vrf/mocks/VRFCoordinatorV2Mock.sol";

contract FullSystemTest is Test {
    // Contracts
    PlatformFactory factory;
    MockRouter router;
    MockWETH weth;
    VariableTaxToken token;
    StakingPool stakingPool;
    MultiplierVault vault;
    Lottery lottery;
    Roulette roulette;
    MockLP lpToken;
    LiquidityLocker locker;
    VRFCoordinatorV2Mock vrfMock;

    // Users
    address deployer = address(1);
    address user1 = address(2);
    address user2 = address(3);

    function setUp() public {
        vm.startPrank(deployer);

        // 1. Deploy Infrastructure
        vrfMock = new VRFCoordinatorV2Mock(0.1 ether, 1e9);
        uint64 subId = vrfMock.createSubscription();
        vrfMock.fundSubscription(subId, 100 ether);

        weth = new MockWETH();
        router = new MockRouter(address(weth));
        factory = new PlatformFactory();

        // 2. Create Platform (Token + Staking)
        (address tokenAddr, address poolAddr,,) =
            factory.createPlatform("Nexus Token", "NEX", 1_000_000 ether, deployer, address(router));

        token = VariableTaxToken(payable(tokenAddr));
        stakingPool = StakingPool(payable(poolAddr));

        // 3. Deploy Arcade & Vault
        vault = new MultiplierVault(address(vrfMock), subId, bytes32(0), poolAddr, deployer);
        vrfMock.addConsumer(subId, address(vault));

        lottery = new Lottery(tokenAddr);

        roulette = new Roulette(address(vrfMock), subId, bytes32(0), deployer);
        vrfMock.addConsumer(subId, address(roulette));

        // 4. Deploy Liquidity Locker
        lpToken = new MockLP();
        locker = new LiquidityLocker(address(lpToken));

        // 5. Setup Liquidity
        router.setToken(tokenAddr);
        vm.deal(address(router), 100 ether); // Give router ETH

        // Exclude deployer from tax to avoid messing up volume during setup
        token.setExcluded(deployer, true);

        token.transfer(address(router), 100_000 ether); // Give router Tokens

        // 6. Fund Users
        vm.deal(deployer, 100 ether); // Give deployer ETH
        vm.deal(user1, 10 ether);
        vm.deal(user2, 10 ether);

        // Give user1 some tokens for testing
        token.transfer(user1, 1000 ether);

        vm.stopPrank();
    }

    function test_FullEcosystemFlow() public {
        // Scenario: User 1 Buys -> Tax Collected -> User 2 Stakes -> Rewards Distributed

        // 1. User 1 Buys Tokens (Simulated via Router)
        vm.startPrank(user1);
        uint256 buyAmount = 1 ether;

        // In a real router, we'd swap ETH for Tokens.
        // Our MockRouter simplifies this, but let's simulate the tax effect manually if needed
        // or trust the MockRouter's simple transfer logic if implemented.
        // For this test, let's verify basic token mechanics first.

        uint256 initialBalance = token.balanceOf(user1);
        console.log("User 1 Initial Balance:", initialBalance);

        // Simulate a transfer that would trigger tax (if tax is enabled)
        // Transfer to User 2
        // Current volume is 0 (since deployer was excluded).
        // Tier 1: 0-999 ETH volume -> 2% tax.
        token.transfer(user2, 100 ether);

        uint256 tax = 100 ether * 2 / 100; // 2% tax
        // Note: VariableTaxToken implementation details determine exact tax
        // Let's verify balances changed
        assertEq(token.balanceOf(user2), 100 ether - tax, "Tax should be deducted");

        vm.stopPrank();
    }

    function test_StakingAndRewards() public {
        vm.startPrank(user1);

        // Approve Staking
        token.approve(address(stakingPool), 500 ether);

        // Stake
        stakingPool.stake(500 ether);

        (uint256 stakedAmount,,) = stakingPool.stakes(user1);
        assertEq(stakedAmount, 500 ether, "Staking failed");

        vm.stopPrank();

        // Simulate Rewards Distribution (e.g. from tax buybacks)
        vm.startPrank(deployer);
        // Send some ETH to the pool as "rewards"
        (bool success,) = address(stakingPool).call{value: 1 ether}("");
        require(success, "Reward transfer failed");
        vm.stopPrank();

        // Check User 1 Rewards
        vm.startPrank(user1);
        uint256 pending = stakingPool.pendingRewards(user1);
        console.log("Pending Rewards:", pending);
        assertGt(pending, 0, "Should have rewards");

        stakingPool.claimReward();
        vm.stopPrank();
    }

    function test_LiquidityLocker() public {
        vm.startPrank(user1);

        // Mint LP tokens (Mock)
        lpToken.mint(user1, 100 ether);

        // Approve Locker
        lpToken.approve(address(locker), 100 ether);

        // Lock for 1 month (Index 1)
        locker.deposit(50 ether, 1);

        LiquidityLocker.LockInfo[] memory locks = locker.getUserLocks(user1);
        assertEq(locks.length, 1);
        assertEq(locks[0].amount, 50 ether);
        assertEq(locks[0].multiplier, 125); // 1.25x

        vm.stopPrank();
    }

    function test_RouletteGame() public {
        vm.startPrank(user1);

        // Bet 0.1 ETH on Red (1)
        uint256 betAmount = 0.1 ether;

        // We need to mock the VRF response
        // 1. Place Bet & Spin
        // The spin function triggers the VRF request.
        // Since spin() doesn't return the requestId, we can predict it (MockVRF starts at 1)
        // or capture it from logs. For simplicity in this test, we assume it's 1.

        vm.recordLogs();
        roulette.spin{value: betAmount}(1); // 1 = Red (simplified logic, actually betting on number 1)

        Vm.Log[] memory entries = vm.getRecordedLogs();
        // Find the RequestId from logs if needed, or just assume 1 for the first request
        uint256 requestId = 1;

        // 3. Fulfill Randomness (Mock VRF)
        // We need to be the VRF Coordinator to call fulfillRandomWords
        // But the MockVRF allows us to call fulfillRandomWords directly if we know the requestId

        // In the MockVRF, we can call fulfillRandomWords with the requestId and the consumer address
        // However, the standard MockVRF usually has a helper `fulfillRandomWords(requestId, consumer)`

        // Let's simulate a winning number for Red (e.g., 1)
        uint256[] memory randomWords = new uint256[](1);
        randomWords[0] = 1; // Random word that might map to a red number

        // Note: The actual mapping depends on the contract logic (mod 37)
        // If logic is `randomWord % 37`, then 1 % 37 = 1 (Red)

        vm.stopPrank();

        // Fulfill as VRF
        vrfMock.fulfillRandomWordsWithOverride(requestId, address(roulette), randomWords);

        vm.startPrank(user1);
        // Check if we won (balance should increase or claimable)
        // This depends on if Roulette pays out instantly or via claim
        // Based on previous code, it seemed to be claim-based or instant.
        // Let's just check the round status if possible

        // (Assuming there's a way to check result)
        vm.stopPrank();
    }
}
